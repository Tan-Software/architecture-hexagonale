# [Tansoftware](https://www.tansoftware.com) - architecture : Hexagonale [![fr](https://raw.githubusercontent.com/gosquared/flags/master/flags/flags/shiny/24/France.png)](https://raw.githubusercontent.com/gosquared/flags/master/flags/flags/shiny/24/France.png)


# Table des mati√®res

* [Introduction](#introduction)
* [Les diff√©rentes couches](#les-diff√©rentes-couches)
* [L'inversion de d√©pendance](#linversion-de-d√©pendance)
* [Le test-driven development](#le-test-driven-development)
* [Symfony en hexagonale](#symfony-en-hexagonale)

## Introduction

Le pattern Hexagonal est une architecture logicielle qui vise √† organiser les composants d'une application (les classes, les modules, les fonctions, etc) en **couches** et √† **isoler** la logique m√©tier de l'application des d√©tails techniques tels que la persistance des donn√©es ou l'interface utilisateur.

Le c≈ìur du pattern Hexagonal r√©side dans la cr√©ation d'une couche centrale, appel√©e **"domain" ou "business logic"**, qui contient les [r√®gles m√©tiers](https://fr.wikipedia.org/wiki/R%C3%A8gles_m%C3%A9tier) et les [cas d'utilisation](https://fr.wikipedia.org/wiki/Cas_d%27utilisation) de l'application. Cette couche centrale est enti√®rement ind√©pendante des autres couches et communique uniquement avec elles par le biais de ports d'entr√©e/sortie d√©finis.

La couche **d'infrastructure**, qui contient les d√©tails techniques de l'application tels que la persistance des donn√©es, la communication r√©seau, etc., communique avec la couche centrale via des adaptateurs qui impl√©mentent les ports d√©finis.

La couche de **pr√©sentation**, qui g√®re l'interface utilisateur de l'application, communique √©galement avec la couche centrale via des adaptateurs.

### Mod√®le d'architecture hexagonale
La couche centrale est repr√©sent√©e par l'hexagone int√©rieur, tandis que les couches d'infrastructure et de pr√©sentation sont repr√©sent√©es par les hexagones ext√©rieurs. Les adaptateurs sont repr√©sent√©s par les fl√®ches reliant les diff√©rentes couches.
```mermaid
graph TD
subgraph Application
A[Use Cases] -->B(Ports)
C[Entities] --> B
D[Controllers] --> B
end
subgraph Infrastructure
F[Frameworks & Drivers] -->B
end
subgraph Domain
G[Entities] -->E(Interfaces)
E --> B
H[Business Rules] -->E
end

```

[üîù Retour en haut de page](#table-des-mati√®res)

## Les diff√©rentes couches
L'architecture hexagonale repose sur une organisation en diff√©rentes couches, chacune ayant une **responsabilit√© sp√©cifique** dans l'application. Ces couches sont g√©n√©ralement les suivantes :

### Le c≈ìur de l'application (Domaine)
Au centre de cette architecture se trouve le c≈ìur de l'application, qui contient la logique m√©tier et les entit√©s. Cette partie est totalement ind√©pendante des d√©tails techniques et des interfaces externes, ce qui la rend facilement testable.

### Ports
Les ports d√©finissent les contrats ou interfaces par lesquels le c≈ìur de l'application interagit avec le monde ext√©rieur. Il existe g√©n√©ralement deux types de ports :

### Ports primaires
Ils d√©finissent les fonctionnalit√©s fournies par le c≈ìur de l'application. Par exemple, une API pour cr√©er un nouvel utilisateur.

### Ports secondaires
Ils d√©finissent les fonctionnalit√©s attendues par le c≈ìur de l'application mais impl√©ment√©es √† l'ext√©rieur, comme l'acc√®s √† une base de donn√©es.
Adaptateurs

## Les adaptateurs sont des impl√©mentations concr√®tes des ports. 
Ils "adaptent" les interfaces externes (comme une base de donn√©es, une interface utilisateur ou un service web) pour qu'elles puissent communiquer avec le c≈ìur de l'application via les ports.

### Adaptateurs primaires
Ils re√ßoivent des requ√™tes du monde ext√©rieur et les transmettent au c≈ìur de l'application via les ports primaires. Par exemple, une interface utilisateur web.

### Adaptateurs secondaires
Ils impl√©mentent les fonctionnalit√©s d√©finies par les ports secondaires. Par exemple, une impl√©mentation de base de donn√©es.

### Repr√©sentation graphique
Ce diagramme repr√©sente les trois couches principales de la Clean Architecture : le Domain, l'Application et l'Infrastructure. Les fl√®ches indiquent les d√©pendances entre les couches.

Dans le Domain, nous avons les entit√©s m√©tier, les cas d'utilisation et les r√®gles m√©tier. Dans l'Application, nous avons les contr√¥leurs et les view models, qui sont responsables de la gestion des interactions entre les utilisateurs et le syst√®me. 

Enfin, dans l'Infrastructure, nous avons les frameworks et les drivers, qui g√®rent les d√©tails techniques de l'application, tels que la persistance des donn√©es, la communication r√©seau, etc.
```mermaid
graph TD
subgraph Domain
A((Entities)) -- Domain --> B((Use Cases))
B -- Domain --> C((Business Rules))
end
subgraph Application
D((Controllers)) -- Application --> B
D -- Application --> E((ViewModels))
end
subgraph Infrastructure
F((Frameworks & Drivers)) -- Infrastructure --> D
end
```
Les fl√®ches dans le diagramme repr√©sentent les d√©pendances entre les diff√©rentes couches de l'architecture hexagonale. 

Les fl√®ches qui vont de l'infrastructure vers l'application indiquent que l'infrastructure d√©pend de l'application, c'est-√†-dire que les √©l√©ments de l'infrastructure doivent conna√Ætre les √©l√©ments de l'application pour fonctionner correctement. 

Par exemple, la persistance des donn√©es d√©pend des entit√©s m√©tier de l'application, car c'est sur ces entit√©s que ces op√©rations sont effectu√©es.

[üîù Retour en haut de page](#table-des-mati√®res)

## L'inversion de d√©pendance
Ce principe consiste √† inverser les d√©pendances entre les diff√©rentes couches de l'application. Les couches sup√©rieures ne d√©pendent pas des couches inf√©rieures, mais plut√¥t de contrats et d'interfaces d√©finis par ces couches inf√©rieures.

Le but de l'inversion de d√©pendance est de permettre √† chaque couche de l'application de rester ind√©pendante et interchangeable, ainsi si une couche inf√©rieure change (par exemple, la couche d'infrastructure pour la persistance des donn√©es), cela n'aura pas d'impact sur les couches sup√©rieures (par exemple, la couche de pr√©sentation ou la couche de logique m√©tier).

### Exemple
Imaginons que nous ayons une classe `UserService` qui d√©pend directement d'une classe `UserRepository` pour effectuer des op√©rations sur les utilisateurs dans une base de donn√©es. Si nous voulons changer la base de donn√©es utilis√©e ou m√™me simplement les requ√™tes SQL effectu√©es, cela aura un impact direct sur la classe `UserService` et n√©cessitera des modifications dans son code.

Au lieu de cela, nous pouvons utiliser une interface `UserRepositoryInterface` qui d√©finit les op√©rations possibles sur les utilisateurs, et faire en sorte que la classe `UserService` d√©pende de cette interface plut√¥t que de la classe concr√®te `UserRepository`. Ainsi, nous pouvons facilement changer l'impl√©mentation de cette interface sans avoir √† modifier la classe `UserService`.
```mermaid
graph TD
A[UserService] -- d√©pend de --> B(UserRepositoryInterface)
B --> C(UserRepository1)
B --> D(UserRepository2)
```

### Context
Dans le contexte de la Clean Hexagonale, l'inversion de d√©pendance permet de respecter le principe de la s√©paration des pr√©occupations en garantissant que les d√©tails techniques de l'application sont isol√©s des r√®gles m√©tiers. Cela permet √©galement de faciliter les tests unitaires en permettant de tester chaque couche ind√©pendamment des autres.
```mermaid
graph TD
subgraph Application
A[Use Cases] -->B
C[Entities] --> B
D[Controllers] --> B
end
subgraph Infrastructure
F[Frameworks & Drivers] -->G
G -->|Interface| B
end
subgraph Domain
B --> H[Business Rules]
end
```

[üîù Retour en haut de page](#table-des-mati√®res)

## Le test-driven development
Le TDD est un processus it√©ratif de d√©veloppement logiciel dans lequel chaque composant de l'application est test√© de mani√®re isol√©e √† l'aide de tests unitaires.

Les tests sont la principale force motrice de la conception de l'application et visent √† √™tre un guide jusqu'√† l'it√©ration fonctionnelle du code de production.

Ainsi, le principe consiste √† conceptualiser le besoin, √©crire un premier test simpliste, √©crire le code de production correspondant pour r√©pondre √† ce test, et it√©rer jusqu'√† ce que l'objectif soit atteint. 

Une fois cet objectif atteint, un autre cas de test peut √™tre √©crit pour la m√™me fonctionnalit√© afin de couvrir diff√©rents sc√©narios ou besoins. Cela permet de s'assurer que le code d√©velopp√© r√©pond √† l'ensemble des exigences de l'application.

### Structure en couches
Pour illustrer cela, le diagramme suivant indique avec une fl√®che en boucle entre les couches, la repr√©sentation it√©rative du TDD.
```mermaid
graph TD
subgraph Application
A[Use Cases] -->B
C[Entities] --> B
D[Controllers] --> B
end
subgraph Infrastructure
F[Frameworks & Drivers] -->G
G -->|Interface| B
end
subgraph Domain
B --> H[Business Rules]
end
H --> A
```

[üîù Retour en haut de page](#table-des-mati√®res)

## Symfony en hexagonale
Ce diagramme repr√©sente les diff√©rentes classes principales d'une application Symfony, telles que le `AppKernel` qui permet d'enregistrer les bundles, les `Bundle` qui contiennent des services, des contr√¥leurs et des entit√©s, les `Service` qui contiennent la logique m√©tier, les `Controller` qui g√®rent les requ√™tes HTTP, les `View` qui sont les templates associ√©s aux contr√¥leurs, les `Entity` qui repr√©sentent les objets m√©tier et les `Repository` qui permettent de les manipuler en base de donn√©es. Le diagramme inclut √©galement les classes associ√©es √† la gestion des √©v√©nements, avec les `Event`, les `EventListener` et les `EventSubscriber`.
```mermaid
classDiagram
class AppKernel {
    -registerBundles()
    -registerContainerConfiguration()
}
class Bundle
class EntityRepository
class Service {
    +__construct()
}
class Controller {
    +__construct()
}
class View {
    -controller
    -template
}
class Entity
class Repository
class DependencyInjection {
    -Extension
    -CompilerPassInterface
}
class Event {
    -name
    -data
    +__construct(name, data)
}
class EventListener
class EventSubscriber {
    +getSubscribedEvents()
}

AppKernel --> Bundle
AppKernel --> DependencyInjection
Bundle --> EntityRepository
Bundle --> Service
Bundle --> Controller
Service --> Repository
Controller --> View
Repository --> Entity
EventListener --> Event
EventSubscriber --> Event
```

### Exemple concret : une application de gestion de t√¢ches
Imaginons une application permettant de cr√©er et g√©rer des t√¢ches avec des priorit√©s et des dates d'√©ch√©ance, disposant √©galement d'une fonctionnalit√© de recherche et d'une interface utilisateur pour l'ajout et la modification des t√¢ches.

### Architecture g√©n√©rale de l'application
Voici une repr√©sentation possible de l'architecture g√©n√©rale de l'application

```mermaid
classDiagram
    class Task {
        <<entity>>
        -id: int
        -title: string
        -description: string
        -priority: int
        -dueDate: datetime
    }

    class TaskRepository_interface {
        +create(task: Task): void
        +update(task: Task): void
        +delete(id: int): void
        +find(id: int): Task
        +findAll(): Task[]
    }

    class TaskUseCase_interface {
        +create(title: string, description: string, priority: int, dueDate: datetime): void
        +update(id: int, title: string, description: string, priority: int, dueDate: datetime): void
        +delete(id: int): void
        +find(id: int): Task
        +findAll(): Task[]
    }

    class TaskController {
        <<controller>>
        +create(request: Request): Response
        +update(request: Request): Response
        +delete(request: Request): Response
        +show(request: Request): Response
        +index(request: Request): Response
    }

    class TaskPresenter {
        <<presenter>>
        +present(task: Task): Response
        +presentCollection(tasks: Task[]): Response
    }

    class TaskRepositoryImpl {
        <<repository>>
        +create(task: Task): void
        +update(task: Task): void
        +delete(id: int): void
        +find(id: int): Task
        +findAll(): Task[]
    }

    class TaskUseCaseImpl {
        <<usecase>>
        -repository: TaskRepository_interface
        +__construct(repository: TaskRepository_interface)
        +create(title: string, description: string, priority: int, dueDate: datetime): void
        +update(id: int, title: string, description: string, priority: int, dueDate: datetime): void
        +delete(id: int): void
        +find(id: int): Task
        +findAll(): Task[]
    }

    TaskController --> TaskPresenter
    TaskPresenter --> TaskController
    TaskController --> TaskUseCase_interface
    TaskUseCase_interface --> TaskController
    TaskUseCase_interface --> TaskRepository_interface
    TaskRepository_interface --> TaskUseCase_interface
    TaskRepositoryImpl --> TaskRepository_interface
    TaskUseCaseImpl --> TaskUseCase_interface
    TaskUseCaseImpl --> TaskRepository_interface

```
### Description
-   `Task` : une entit√© repr√©sentant une t√¢che, qui contient des attributs tels que `id`, `title`, `description`, `priority`, et `dueDate`.
-   `TaskRepository_interface` : une interface qui d√©finit les m√©thodes pour la couche d'infrastructure qui communique avec la couche centrale.
-   `TaskUseCase_interface` : une interface qui d√©finit les m√©thodes pour la couche centrale qui contient les r√®gles m√©tier de l'application.
-   `TaskController` : une classe qui g√®re les requ√™tes HTTP de l'utilisateur et les transmet √† la couche centrale pour effectuer les op√©rations appropri√©es.
-   `TaskPresenter` : une classe qui g√®re la pr√©sentation des r√©sultats renvoy√©s par la couche centrale pour √™tre envoy√©s au client (sous forme de r√©ponse HTTP).
-   `TaskRepositoryImpl` : une classe qui impl√©mente l'interface `TaskRepository_interface` pour fournir les m√©thodes de communication avec la base de donn√©es.
-   `TaskUseCaseImpl` : une classe qui impl√©mente l'interface `TaskUseCase_interface` pour fournir les m√©thodes de la couche centrale, en utilisant le repository pour persister les donn√©es.

[üîù Retour en haut de page](#table-des-mati√®res)
